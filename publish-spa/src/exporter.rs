use crate::graph::Graph;
use crate::parser::{Block, Page};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct ExportConfig {
    pub theme: String,
    pub include_backlinks: bool,
    pub include_graph_view: bool,
    pub custom_css: Option<String>,
}

/// Export entire graph to HTML files
pub fn export_graph_to_html(graph: &Graph, config: &ExportConfig) -> Result<HashMap<String, String>, String> {
    let mut html_files = HashMap::new();

    // Generate index page
    let index_html = generate_index_page(graph, config);
    html_files.insert("index.html".to_string(), index_html);

    // Generate individual page HTML
    for page in graph.pages() {
        let backlinks = graph.get_backlinks(&page.path);
        let page_html = export_page_to_html(page, &backlinks, config);

        // Convert path to HTML file path
        let html_path = page.path
            .trim_end_matches(".md")
            .trim_end_matches(".markdown")
            .to_string() + ".html";

        html_files.insert(html_path, page_html);
    }

    // Generate CSS file
    html_files.insert("style.css".to_string(), generate_css(config));

    // Generate JavaScript file
    html_files.insert("app.js".to_string(), generate_js(config));

    Ok(html_files)
}

fn generate_index_page(graph: &Graph, _config: &ExportConfig) -> String {
    let stats = graph.stats();

    let mut html = String::from("<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n");
    html.push_str("<meta charset=\"UTF-8\">\n");
    html.push_str("<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n");
    html.push_str("<title>Logseq Published Graph</title>\n");
    html.push_str("<link rel=\"stylesheet\" href=\"style.css\">\n");
    html.push_str("</head>\n<body>\n");

    html.push_str("<div class=\"container\">\n");
    html.push_str("<header>\n");
    html.push_str("<h1>üìö Logseq Published Graph</h1>\n");
    html.push_str(&format!("<p class=\"stats\">{} pages ‚Ä¢ {} blocks ‚Ä¢ {} links</p>\n",
        stats.page_count, stats.total_blocks, stats.total_links));
    html.push_str("</header>\n");

    html.push_str("<main>\n");
    html.push_str("<h2>All Pages</h2>\n");
    html.push_str("<ul class=\"page-list\">\n");

    let mut pages: Vec<_> = graph.pages().collect();
    pages.sort_by(|a, b| a.title.cmp(&b.title));

    for page in pages {
        let html_path = sanitize_html_path(&page.path);
        let escaped_title = escape_html_string(&page.title);
        html.push_str(&format!("<li><a href=\"{}\">{}</a></li>\n", html_path, escaped_title));
    }

    html.push_str("</ul>\n");
    html.push_str("</main>\n");

    html.push_str("<footer>\n");
    html.push_str("<p>Generated by Logseq Publisher ‚Ä¢ Built with Rust + WASM</p>\n");
    html.push_str("</footer>\n");
    html.push_str("</div>\n");

    html.push_str("<script src=\"app.js\"></script>\n");
    html.push_str("</body>\n</html>");

    html
}

/// Export single page to standalone HTML
pub fn export_page_to_html(page: &Page, backlinks: &[String], config: &ExportConfig) -> String {
    let mut html = String::from("<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n");
    html.push_str("<meta charset=\"UTF-8\">\n");
    html.push_str("<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n");
    let escaped_title = escape_html_string(&page.title);
    html.push_str(&format!("<title>{}</title>\n", escaped_title));
    html.push_str("<link rel=\"stylesheet\" href=\"../style.css\">\n");
    html.push_str("</head>\n<body>\n");

    html.push_str("<div class=\"container\">\n");
    html.push_str("<nav><a href=\"../index.html\">‚Üê Back to Index</a></nav>\n");

    let escaped_path = escape_html_string(&page.path);
    html.push_str(&format!("<article data-path=\"{}\">\n", escaped_path));
    html.push_str(&format!("<h1>{}</h1>\n", escaped_title));

    // Properties
    if !page.properties.is_empty() {
        html.push_str("<div class=\"properties\">\n");
        for (key, value) in &page.properties {
            let escaped_key = escape_html_string(key);
            let escaped_value = escape_html_string(value);
            html.push_str(&format!("<div><strong>{}:</strong> {}</div>\n", escaped_key, escaped_value));
        }
        html.push_str("</div>\n");
    }

    // Tags
    if !page.tags.is_empty() {
        html.push_str("<div class=\"tags\">\n");
        for tag in &page.tags {
            let escaped_tag = escape_html_string(tag);
            html.push_str(&format!("<span class=\"tag\">#{}</span>\n", escaped_tag));
        }
        html.push_str("</div>\n");
    }

    // Blocks
    html.push_str("<div class=\"blocks\">\n");
    for block in &page.blocks {
        html.push_str(&render_block(block));
    }
    html.push_str("</div>\n");

    // Backlinks
    if config.include_backlinks && !backlinks.is_empty() {
        html.push_str("<div class=\"backlinks\">\n");
        html.push_str("<h2>üìé Linked References</h2>\n");
        html.push_str("<ul>\n");
        for backlink in backlinks {
            let html_path = sanitize_html_path(backlink);
            let escaped_backlink = escape_html_string(backlink);
            html.push_str(&format!("<li><a href=\"{}\">{}</a></li>\n", html_path, escaped_backlink));
        }
        html.push_str("</ul>\n");
        html.push_str("</div>\n");
    }

    html.push_str("</article>\n");
    html.push_str("</div>\n");

    html.push_str("<script src=\"../app.js\"></script>\n");
    html.push_str("</body>\n</html>");

    html
}

fn render_block(block: &Block) -> String {
    let mut html = String::new();

    html.push_str(&format!("<div class=\"block\" data-id=\"{}\" data-level=\"{}\">\n",
        block.id, block.level));
    html.push_str(&format!("<div class=\"block-content\">{}</div>\n",
        render_markdown(&block.content)));

    if !block.children.is_empty() {
        html.push_str("<div class=\"block-children\">\n");
        for child in &block.children {
            html.push_str(&render_block(child));
        }
        html.push_str("</div>\n");
    }

    html.push_str("</div>\n");

    html
}

fn render_markdown(content: &str) -> String {
    // First escape HTML to prevent XSS
    let mut result = escape_html_string(content);

    // Convert wiki-links [[page]] to HTML links (safe, escaped above)
    let link_regex = regex::Regex::new(r"\[\[([^\]]+)\]\]").unwrap();
    result = link_regex.replace_all(&result, |caps: &regex::Captures| {
        let link_text = &caps[1]; // Already escaped
        let html_path = sanitize_html_path(link_text);
        format!("<a href=\"{}\" class=\"wiki-link\">{}</a>", html_path, link_text)
    }).to_string();

    // Convert tags #tag to styled spans
    let tag_regex = regex::Regex::new(r"#(\w+)").unwrap();
    result = tag_regex.replace_all(&result, "<span class=\"tag\">#$1</span>").to_string();

    // Bold **text**
    let bold_regex = regex::Regex::new(r"\*\*([^*]+)\*\*").unwrap();
    result = bold_regex.replace_all(&result, "<strong>$1</strong>").to_string();

    // Italic *text*
    let italic_regex = regex::Regex::new(r"\*([^*]+)\*").unwrap();
    result = italic_regex.replace_all(&result, "<em>$1</em>").to_string();

    // Code `code`
    let code_regex = regex::Regex::new(r"`([^`]+)`").unwrap();
    result = code_regex.replace_all(&result, "<code>$1</code>").to_string();

    result
}

/// Escape HTML special characters to prevent XSS
fn escape_html_string(s: &str) -> String {
    s.chars()
        .map(|c| match c {
            '<' => "&lt;".to_string(),
            '>' => "&gt;".to_string(),
            '&' => "&amp;".to_string(),
            '"' => "&quot;".to_string(),
            '\'' => "&#x27;".to_string(),
            _ => c.to_string(),
        })
        .collect()
}

/// Sanitize file path for HTML output
fn sanitize_html_path(path: &str) -> String {
    path.trim_end_matches(".md")
        .trim_end_matches(".markdown")
        .to_string() + ".html"
}

fn generate_css(config: &ExportConfig) -> String {
    let mut css = String::from(r#"/* Logseq Publisher Styles */

:root {
    --bg-color: #ffffff;
    --text-color: #2d3748;
    --link-color: #3182ce;
    --border-color: #e2e8f0;
    --tag-bg: #edf2f7;
    --block-border: #cbd5e0;
}

* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
    line-height: 1.6;
    color: var(--text-color);
    background: var(--bg-color);
}

.container {
    max-width: 900px;
    margin: 0 auto;
    padding: 2rem;
}

header {
    margin-bottom: 3rem;
    padding-bottom: 1rem;
    border-bottom: 2px solid var(--border-color);
}

h1 {
    font-size: 2rem;
    margin-bottom: 0.5rem;
}

h2 {
    font-size: 1.5rem;
    margin: 1.5rem 0 1rem;
}

.stats {
    color: #718096;
    font-size: 0.95rem;
}

.page-list {
    list-style: none;
    padding: 0;
}

.page-list li {
    margin: 0.5rem 0;
}

.page-list a {
    color: var(--link-color);
    text-decoration: none;
    padding: 0.5rem;
    display: block;
    border-radius: 0.25rem;
    transition: background 0.2s;
}

.page-list a:hover {
    background: #ebf8ff;
}

nav {
    margin-bottom: 2rem;
}

nav a {
    color: var(--link-color);
    text-decoration: none;
}

.block {
    margin: 0.5rem 0;
    padding-left: 1.5rem;
}

.block-content {
    padding: 0.25rem 0;
}

.block-children {
    margin-left: 1rem;
    border-left: 2px solid var(--block-border);
    padding-left: 1rem;
}

.wiki-link {
    color: var(--link-color);
    text-decoration: none;
    border-bottom: 1px dotted var(--link-color);
}

.wiki-link:hover {
    background: #ebf8ff;
    border-bottom-style: solid;
}

.tag {
    background: var(--tag-bg);
    padding: 0.125rem 0.5rem;
    border-radius: 0.25rem;
    font-size: 0.875rem;
    margin: 0 0.25rem;
    white-space: nowrap;
}

.properties {
    background: #f7fafc;
    padding: 1rem;
    border-radius: 0.5rem;
    margin: 1rem 0;
    font-size: 0.875rem;
}

.backlinks {
    margin-top: 3rem;
    padding-top: 2rem;
    border-top: 2px solid var(--border-color);
}

.backlinks ul {
    list-style: none;
    padding: 0;
}

.backlinks li {
    margin: 0.5rem 0;
}

code {
    background: #f7fafc;
    padding: 0.125rem 0.25rem;
    border-radius: 0.25rem;
    font-family: 'Monaco', 'Courier New', monospace;
    font-size: 0.875rem;
}

footer {
    margin-top: 3rem;
    padding-top: 2rem;
    border-top: 1px solid var(--border-color);
    text-align: center;
    color: #718096;
    font-size: 0.875rem;
}
"#);

    if let Some(custom_css) = &config.custom_css {
        css.push('\n');
        css.push_str(custom_css);
    }

    css
}

fn generate_js(_config: &ExportConfig) -> String {
    String::from(r#"// Logseq Publisher JavaScript

document.addEventListener('DOMContentLoaded', () => {
    console.log('Logseq Publisher initialized');

    // Add click handlers for navigation
    document.addEventListener('click', (e) => {
        if (e.target.classList.contains('wiki-link')) {
            // Let browser handle navigation normally
            console.log('Navigate to:', e.target.getAttribute('href'));
        }
    });
});
"#)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_markdown_rendering() {
        let content = "This is **bold** and *italic* with [[link]] and #tag and `code`";
        let html = render_markdown(content);
        assert!(html.contains("<strong>bold</strong>"));
        assert!(html.contains("<em>italic</em>"));
        assert!(html.contains("wiki-link"));
        assert!(html.contains("class=\"tag\""));
        assert!(html.contains("<code>code</code>"));
    }
}
