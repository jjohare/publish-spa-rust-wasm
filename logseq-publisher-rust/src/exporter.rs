use crate::graph::Graph;
use crate::parser::{Block, Page};
use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize)]
pub struct ExportConfig {
    pub theme: String,
    pub include_backlinks: bool,
    pub include_graph_view: bool,
    pub custom_css: Option<String>,
}

/// Export graph to HTML
pub fn export_to_html(graph: &Graph, config: &ExportConfig) -> Result<String, String> {
    let stats = graph.stats();

    let mut html = String::from("<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n");
    html.push_str("<meta charset=\"UTF-8\">\n");
    html.push_str("<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n");
    html.push_str("<title>Logseq Published Graph</title>\n");
    html.push_str(&generate_css(config));
    html.push_str("</head>\n<body>\n");

    // Header
    html.push_str("<header>\n");
    html.push_str(&format!("<h1>Published Logseq Graph</h1>\n"));
    html.push_str(&format!("<p>{} pages • {} blocks • {} links</p>\n",
        stats.page_count, stats.total_blocks, stats.total_links));
    html.push_str("</header>\n");

    // Main content
    html.push_str("<main>\n");
    html.push_str("<div id=\"content\"></div>\n");
    html.push_str("</main>\n");

    // Footer
    html.push_str("<footer>\n");
    html.push_str("<p>Generated by Logseq Publisher • Built with Rust + WASM</p>\n");
    html.push_str("</footer>\n");

    html.push_str(&generate_js(config));
    html.push_str("</body>\n</html>");

    Ok(html)
}

/// Export single page to HTML
pub fn export_page_to_html(page: &Page, backlinks: &[String], config: &ExportConfig) -> String {
    let mut html = String::new();

    html.push_str(&format!("<article data-path=\"{}\">\n", page.path));
    html.push_str(&format!("<h1>{}</h1>\n", page.title));

    // Properties
    if !page.properties.is_empty() {
        html.push_str("<div class=\"properties\">\n");
        for (key, value) in &page.properties {
            html.push_str(&format!("<div><strong>{}:</strong> {}</div>\n", key, value));
        }
        html.push_str("</div>\n");
    }

    // Tags
    if !page.tags.is_empty() {
        html.push_str("<div class=\"tags\">\n");
        for tag in &page.tags {
            html.push_str(&format!("<span class=\"tag\">#{}</span>\n", tag));
        }
        html.push_str("</div>\n");
    }

    // Blocks
    html.push_str("<div class=\"blocks\">\n");
    for block in &page.blocks {
        html.push_str(&render_block(block));
    }
    html.push_str("</div>\n");

    // Backlinks
    if config.include_backlinks && !backlinks.is_empty() {
        html.push_str("<div class=\"backlinks\">\n");
        html.push_str("<h2>Linked References</h2>\n");
        html.push_str("<ul>\n");
        for backlink in backlinks {
            html.push_str(&format!("<li><a href=\"#{}\">{}</a></li>\n", backlink, backlink));
        }
        html.push_str("</ul>\n");
        html.push_str("</div>\n");
    }

    html.push_str("</article>\n");

    html
}

fn render_block(block: &Block) -> String {
    let mut html = String::new();

    html.push_str(&format!("<div class=\"block\" data-id=\"{}\" data-level=\"{}\">\n",
        block.id, block.level));
    html.push_str(&format!("<div class=\"block-content\">{}</div>\n",
        render_markdown(&block.content)));

    if !block.children.is_empty() {
        html.push_str("<div class=\"block-children\">\n");
        for child in &block.children {
            html.push_str(&render_block(child));
        }
        html.push_str("</div>\n");
    }

    html.push_str("</div>\n");

    html
}

fn render_markdown(content: &str) -> String {
    // Convert wiki-links [[page]] to HTML links
    let link_regex = regex::Regex::new(r"\[\[([^\]]+)\]\]").unwrap();
    let with_links = link_regex.replace_all(content, "<a href=\"#$1\" class=\"wiki-link\">$1</a>");

    // Convert tags #tag to styled spans
    let tag_regex = regex::Regex::new(r"#(\w+)").unwrap();
    let with_tags = tag_regex.replace_all(&with_links, "<span class=\"tag\">#$1</span>");

    // Basic markdown (bold, italic)
    let bold_regex = regex::Regex::new(r"\*\*([^*]+)\*\*").unwrap();
    let with_bold = bold_regex.replace_all(&with_tags, "<strong>$1</strong>");

    let italic_regex = regex::Regex::new(r"\*([^*]+)\*").unwrap();
    let with_italic = italic_regex.replace_all(&with_bold, "<em>$1</em>");

    with_italic.to_string()
}

fn generate_css(config: &ExportConfig) -> String {
    let mut css = String::from("<style>\n");

    css.push_str(r#"
:root {
    --bg-color: #ffffff;
    --text-color: #2d3748;
    --link-color: #3182ce;
    --border-color: #e2e8f0;
}

* { box-sizing: border-box; margin: 0; padding: 0; }

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    line-height: 1.6;
    color: var(--text-color);
    background: var(--bg-color);
    max-width: 900px;
    margin: 0 auto;
    padding: 2rem;
}

header {
    margin-bottom: 3rem;
    padding-bottom: 1rem;
    border-bottom: 2px solid var(--border-color);
}

h1 { font-size: 2rem; margin-bottom: 0.5rem; }
h2 { font-size: 1.5rem; margin: 1.5rem 0 1rem; }

.block {
    margin: 0.5rem 0;
    padding-left: calc(var(--level, 0) * 1.5rem);
}

.block-content {
    padding: 0.25rem 0;
}

.block-children {
    margin-left: 1.5rem;
    border-left: 2px solid var(--border-color);
    padding-left: 1rem;
}

.wiki-link {
    color: var(--link-color);
    text-decoration: none;
    border-bottom: 1px dotted var(--link-color);
}

.wiki-link:hover {
    background: #ebf8ff;
}

.tag {
    background: #edf2f7;
    padding: 0.125rem 0.5rem;
    border-radius: 0.25rem;
    font-size: 0.875rem;
    margin: 0 0.25rem;
}

.properties {
    background: #f7fafc;
    padding: 1rem;
    border-radius: 0.5rem;
    margin: 1rem 0;
    font-size: 0.875rem;
}

.backlinks {
    margin-top: 3rem;
    padding-top: 2rem;
    border-top: 2px solid var(--border-color);
}

footer {
    margin-top: 3rem;
    padding-top: 2rem;
    border-top: 1px solid var(--border-color);
    text-align: center;
    color: #718096;
    font-size: 0.875rem;
}
"#);

    if let Some(custom_css) = &config.custom_css {
        css.push_str(custom_css);
    }

    css.push_str("</style>\n");
    css
}

fn generate_js(config: &ExportConfig) -> String {
    let mut js = String::from("<script>\n");

    js.push_str(r#"
// Basic navigation
document.addEventListener('click', (e) => {
    if (e.target.classList.contains('wiki-link')) {
        e.preventDefault();
        const target = e.target.getAttribute('href').substring(1);
        console.log('Navigate to:', target);
        // In full implementation, load page via WASM
    }
});

// Initialize
console.log('Logseq Publisher initialized');
"#);

    if config.include_graph_view {
        js.push_str("// Graph view would be initialized here\n");
    }

    js.push_str("</script>\n");
    js
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_markdown_rendering() {
        let content = "This is **bold** and *italic* with [[link]] and #tag";
        let html = render_markdown(content);
        assert!(html.contains("<strong>bold</strong>"));
        assert!(html.contains("<em>italic</em>"));
        assert!(html.contains("wiki-link"));
        assert!(html.contains("class=\"tag\""));
    }
}
